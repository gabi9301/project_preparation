영속성 컨텍스트
(엔티티를 영구 저장하는 환경)

EntityManager.persist(entity);
위 코드는 엔티티를 DB에 저장한다는 의미가 아니라 영속성 컨텍스트에 저장한다는 의미

엔티티의 생명주기는 다음과 같다.

-비영속(new/transient)
 영속성 컨텍스트와 전혀 관계 없는 새로운 상태

-영속(managed)
 영속성 컨텍스트에 관리되는 상태

-준영속(detached)
 영속성 컨텍스트에 저장되었다가 분리된 상태

-삭제(removed)
 삭제된 상태

영속 상태가 되었다고 해서 DB에 저장된 것은 아니다.
DB에 저장하려면 트랜젝션을 커밋해야 한다.

---------------------------------------------------------------
중요 1.
영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.
(하나의 트랜젝션 내에서만 활용되는 캐시)

하나의 엔티티를 저장(entityManger.persist(Entity))한 후 동일한 트랜젝션 내에서 해당 PK값으로 조회하면
조회(SELECT) 쿼리가 DB로 발송되지 않는 것을 확인할 수 있다.
이는 엔티티를 저장하는 시점에서 이미 1차 캐시에 정보가 저장되었기 때문이다.
그리고 EntityManager는 DB를 조회하기 전에 1차 캐시를 우선적으로 조회한다.

예시)
Member findMember1 = em.find(Member.class, primaryKey: 101L);
Member findMember2 = em.find(Member.class, primaryKey: 101L);

위 코드를 한 트랜젝션 내에서 수행했을 때 (DB에 이미 해당 정보가 있다고 가정)
첫 줄의 코드를 통해 조회(SELECT) 쿼리가 DB로 보내지지만
두 번째 줄의 코드에선 조회 쿼리가 수행되지 않는다.
이미 첫 줄에서 조회를 할 때 해당 엔티티를 1차 캐시에 저장했기 때문에
이 정보를 읽어오게 된다.

중요 2.
영속 엔티티는 동일성이 보장된다.

Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

위와 같은 경우 a 는 b 와 동일하다. ( a == b => true)

중요 3.
쓰기 지연이 가능하다.(쓰기 지연 SQL 저장소 존재)

트랜젝션을 커밋하는 순간에 쿼리가 실행되므로
그 이전 시점까지 여러 엔티티를 등록했을 때 해당 엔티티들을 한 번에 INSERT 가능하다.
(JPA batch 개념)

중요 4.
엔티티를 수정하면 변경을 감지한다.
마치 자바 컬렉션처럼 엔티티를 수정했을 때 해당 내용을 DB로 다시 저장할 필요가 없다.
JPA가 자체적으로 변경을 감지해 UPDATE 쿼리를 생성해 DB로 발송한다.

1차 캐시 내에는 아이디(PK), 엔티티, 스냅샷이 있는데
스냅샷은 엔티티를 최초로 조회했을 때의 상태를 저장한 것이다. 
만약 트랜젝션이 커밋될 때 엔티티와 스냅샷을 비교해 달라진 점이 있다면
UPDATE 쿼리로 이를 반영한다.









